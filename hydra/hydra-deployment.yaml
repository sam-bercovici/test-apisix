# Ory Hydra deployment for M2M OAuth2/OIDC
apiVersion: apps/v1
kind: Deployment
metadata:
  name: hydra
  namespace: hydra
  labels:
    app: hydra
spec:
  replicas: 1
  selector:
    matchLabels:
      app: hydra
  template:
    metadata:
      labels:
        app: hydra
    spec:
      initContainers:
        # Wait for PostgreSQL to be ready
        - name: wait-for-postgres
          image: busybox:1.36
          command:
            - sh
            - -c
            - |
              until nc -z hydra-postgres.hydra.svc.cluster.local 5432; do
                echo "Waiting for PostgreSQL..."
                sleep 2
              done
              echo "PostgreSQL is ready"
      containers:
        - name: hydra
          image: oryd/hydra:v2.2.0
          args:
            - serve
            - all
            - --dev  # Remove in production
          ports:
            - name: public
              containerPort: 4444
            - name: admin
              containerPort: 4445
          env:
            - name: DSN
              value: postgres://hydra:hydra@hydra-postgres.hydra.svc.cluster.local:5432/hydra?sslmode=disable
            - name: URLS_SELF_ISSUER
              value: http://hydra.local/auth
            - name: URLS_CONSENT
              value: http://localhost:3000/consent  # Not used for M2M
            - name: URLS_LOGIN
              value: http://localhost:3000/login    # Not used for M2M
            - name: STRATEGIES_ACCESS_TOKEN
              value: jwt
            - name: TTL_ACCESS_TOKEN
              value: 1h
            - name: TTL_REFRESH_TOKEN
              value: 0s  # Disable refresh tokens for M2M
            - name: OAUTH2_EXPOSE_INTERNAL_ERRORS
              value: "false"
            - name: LOG_LEVEL
              value: info
            - name: LOG_FORMAT
              value: json
            # Disable consent flow for client_credentials grant
            - name: OAUTH2_CLIENT_CREDENTIALS_DEFAULT_GRANT_ALLOWED_SCOPE
              value: "true"
            # System secret for encrypting client secrets (32+ chars)
            # In production, use a Kubernetes Secret instead
            - name: SECRETS_SYSTEM
              value: "this-is-a-32-char-secret-for-dev"
          readinessProbe:
            httpGet:
              path: /health/ready
              port: 4444
            initialDelaySeconds: 5
            periodSeconds: 10
          livenessProbe:
            httpGet:
              path: /health/alive
              port: 4444
            initialDelaySeconds: 15
            periodSeconds: 20
          resources:
            requests:
              cpu: 100m
              memory: 128Mi
            limits:
              cpu: 500m
              memory: 256Mi
